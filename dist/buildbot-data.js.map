{"version":3,"sources":["bowerdeps.js","data.module.js","data.constant.js","classes/base.service.js","classes/build.service.js","classes/builder.service.js","classes/buildrequest.service.js","classes/buildset.service.js","classes/change.service.js","classes/changesource.service.js","classes/forcescheduler.service.js","classes/logs.service.js","classes/master.service.js","classes/properties.service.js","classes/scheduler.service.js","classes/sourcestamp.service.js","classes/step.service.js","classes/worker.service.js","services/data/data.service.js","services/dataUtils/dataUtils.service.js","services/rest/rest.service.js","services/socket/socket.service.js","services/socket/webSocketBackend.service.js","services/socket/websocket.service.js","services/stream/stream.service.js","services/data/collection/collection.service.js","services/data/collection/dataquery.service.js"],"names":[],"mappings":"AAAA;AACA;AACA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"buildbot-data.js","sourcesContent":["(function(){ var _global = (0, eval)('this');\nif (typeof _global.BOWERDEPS === 'undefined') { _global.BOWERDEPS = {}; }\n})();","// Register new module\nclass BBData {\n    constructor() {\n        return [];\n    }\n}\n\nangular.module('bbData', new BBData());\n","class Api {\n    constructor() { return new String('api/v2/'); }\n}\n\nclass Endpoints {\n    constructor() {\n        // Rootlinks\n        return [\n            'builders',\n            'builds',\n            'buildrequests',\n            'workers',\n            'buildsets',\n            'changes',\n            'changesources',\n            'masters',\n            'sourcestamps',\n            'schedulers',\n            'forceschedulers'\n        ];\n    }\n}\n\n\nangular.module('bbData')\n.constant('API', new Api())\n.constant('ENDPOINTS', new Endpoints());\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Base {\n    constructor(dataService, socketService, dataUtilsService) {\n        let BaseInstance;\n        return (BaseInstance = class BaseInstance {\n            constructor(object, _endpoint, childEndpoints) {\n                this._endpoint = _endpoint;\n                if (childEndpoints == null) { childEndpoints = []; }\n                if (!angular.isString(this._endpoint)) {\n                    throw new TypeError(`Parameter 'endpoint' must be a string, not ${typeof this.endpoint}`);\n                }\n\n                this.$accessor = null;\n                // add object fields to the instance\n                this.update(object);\n\n                // generate loadXXX functions\n                this.constructor.generateFunctions(childEndpoints);\n\n                // get the id of the class type\n                const classId = dataUtilsService.classId(this._endpoint);\n                this._id = this[classId];\n\n                // reset endpoint to base\n                if (this._id != null) {\n                    this._endpoint = dataUtilsService.type(this._endpoint);\n                }\n            }\n\n            setAccessor(a) {\n                return this.$accessor = a;\n            }\n\n            update(o) {\n                return angular.extend(this, o);\n            }\n\n            get(...args) {\n                return dataService.get(this._endpoint, this._id, ...Array.from(args));\n            }\n\n            control(method, params) {\n                return dataService.control(this._endpoint, this._id, method, params);\n            }\n\n            // generate endpoint functions for the class\n            static generateFunctions(endpoints) {\n                return endpoints.forEach(e => {\n                    // capitalize endpoint names\n                    const E = dataUtilsService.capitalize(e);\n                    // adds loadXXX functions to the prototype\n                    this.prototype[`load${E}`] = function(...args) {\n                        return this[e] = this.get(e, ...Array.from(args));\n                    };\n\n                    // adds getXXX functions to the prototype\n                    return this.prototype[`get${E}`] = function(...args) {\n                        let query;\n                        [args, query] = Array.from(dataUtilsService.splitOptions(args));\n                        if (this.$accessor) {\n                            if (query.subscribe == null) { query.subscribe = true; }\n                            query.accessor = this.$accessor;\n                        }\n                        return this.get(e, ...Array.from(args), query);\n                    };\n                });\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Base', ['dataService', 'socketService', 'dataUtilsService', Base]);","class Build {\n    constructor(Base, dataService) {\n        let BuildInstance;\n        return (BuildInstance = class BuildInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'changes',           // /changes\n                    'properties',        // /properties\n                    'steps'             // /steps/:name\n                                        // /steps/:stepid\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Build', ['Base', 'dataService', Build]);\n","class Builder {\n    constructor(Base, dataService) {\n        let BuilderInstance;\n        return (BuilderInstance = class BuilderInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'builds',            // /builds/:buildid\n                    'buildrequests',     // /buildrequests/:buildrequestid\n                    'forceschedulers',   // /forceschedulers\n                    'workers',           // /workers/:workerid\n                                        // /workers/:name\n                    'masters'           // /masters/:masterid\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Builder', ['Base', 'dataService', Builder]);\n","class Buildrequest {\n    constructor(Base, dataService) {\n        let BuildrequestInstance;\n        return (BuildrequestInstance = class BuildrequestInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'builds'            // /builds\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Buildrequest', ['Base', 'dataService', Buildrequest]);\n","class Buildset {\n    constructor(Base, dataService) {\n        let BuildsetInstance;\n        return (BuildsetInstance = class BuildsetInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'properties'        // /properties\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Buildset', ['Base', 'dataService', Buildset]);","/*\n * decaffeinate suggestions:\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Change {\n    constructor(Base, dataService, dataUtilsService) {\n        let ChangeInstance;\n        return (ChangeInstance = class ChangeInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint);\n                let { author } = this;\n                if ((this.author == null)) {\n                    author = \"unknown\";\n                }\n\n                const email = dataUtilsService.emailInString(author);\n                // Remove email from author string\n                if (email) {\n                    if  (author.split(' ').length > 1) {\n                        this.author_name = author.replace(new RegExp(`\\\\s<${email}>`), '');\n                        this.author_email = email;\n                    } else {\n                        this.author_name = email.split(\"@\")[0];\n                        this.author_email = email;\n                    }\n                } else {\n                    this.author_name = author;\n                }\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Change', ['Base', 'dataService', 'dataUtilsService', Change]);","class Changesource {\n    constructor(dataService, Base) {\n        let ChangesourceInstance;\n        return (ChangesourceInstance = class ChangesourceInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Changesource', ['dataService', 'Base', Changesource]);","class Forcescheduler {\n    constructor(Base, dataService) {\n        let ForceschedulerInstance;\n        return (ForceschedulerInstance = class ForceschedulerInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Forcescheduler', ['Base', 'dataService', Forcescheduler]);","class Log {\n    constructor(Base, dataService) {\n        let BuildInstance;\n        return (BuildInstance = class BuildInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'chunks',           // /chunks\n                    'contents'\n                ];\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Log', ['Base', 'dataService', Log]);","class Master {\n    constructor(Base, dataService) {\n        let MasterInstance;\n        return (MasterInstance = class MasterInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'builders',          // /builders/:builderid\n                    'workers',           // /workers/:workerid\n                                        // /workers/:name\n                    'changesources',     // /changesources/:changesourceid\n                    'schedulers'        // /schedulers/:schedulerid\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Master', ['Base', 'dataService', Master]);","// damn grammar. I claim that properties singular is propertie\nclass Propertie {\n    constructor(Base, dataService) {\n        let BuildInstance;\n        return (BuildInstance = class BuildInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint, []);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Propertie', ['Base', 'dataService', Propertie]);","class Scheduler {\n    constructor(Base, dataService) {\n        let SchedulerInstance;\n        return (SchedulerInstance = class SchedulerInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Scheduler', ['Base', 'dataService', Scheduler]);","class Sourcestamp {\n    constructor(Base, dataService) {\n        let SourcestampInstance;\n        return (SourcestampInstance = class SourcestampInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'changes'           // /changes\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Sourcestamp', ['Base', 'dataService', Sourcestamp]);","class Step {\n    constructor(Base, dataService) {\n        let BuildInstance;\n        return (BuildInstance = class BuildInstance extends Base {\n            constructor(object, endpoint) {\n                const endpoints = [\n                    'logs'           // /logs\n                ];\n\n                super(object, endpoint, endpoints);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Step', ['Base', 'dataService', Step]);","class Worker {\n    constructor(Base, dataService) {\n        let WorkerInstance;\n        return (WorkerInstance = class WorkerInstance extends Base {\n            constructor(object, endpoint) {\n                super(object, endpoint);\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('Worker', ['Base', 'dataService', Worker]);","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Data {\n    static initClass() {\n        // TODO caching\n        this.prototype.cache = false;\n    }\n    constructor($log, $injector, $q, restService, socketService, dataUtilsService, Collection,\n                ENDPOINTS) {\n        let DataService;\n        return new ((DataService = (function() {\n            let self = undefined;\n            DataService = class DataService {\n                static initClass() {\n                    self = null;\n    \n                //############# utils for testing\n                // register return values for the mocked get function\n                    this.prototype.mocks = {};\n                    this.prototype.spied = false;\n                }\n                constructor() {\n                    self = this;\n                    // setup socket listeners\n                    //socketService.eventStream.onUnsubscribe = @unsubscribeListener\n                    socketService.onclose = this.socketCloseListener;\n                    // generate loadXXX functions for root endpoints\n                    this.constructor.generateEndpoints();\n                }\n\n                // the arguments are in this order: endpoint, id, child, id of child, query\n                get(...args) {\n\n                    // get the query parameters\n                    let accessor, query, subscribePromise;\n                    [args, query] = Array.from(dataUtilsService.splitOptions(args));\n                    let subscribe = (accessor = undefined);\n\n                    // subscribe for changes if 'subscribe' is true\n                    subscribe = query.subscribe === true;\n                    ({ accessor } = query);\n                    if (subscribe && !accessor) {\n                        $log.warn(\"subscribe call should be done after DataService.open()\");\n                        $log.warn(\"for maintaining trace of observers\");\n                        subscribe = false;\n                    }\n\n                    // 'subscribe' is not part of the query\n                    delete query.subscribe;\n                    delete query.accessor;\n\n                    const restPath = dataUtilsService.restPath(args);\n                    // up to date array, this will be returned\n                    const collection = new Collection(restPath, query, accessor);\n\n                    if (subscribe) {\n                        subscribePromise = collection.subscribe();\n                    } else {\n                        subscribePromise = $q.resolve();\n                    }\n\n                    subscribePromise.then(() =>\n                        // get the data from the rest api\n                        restService.get(restPath, query).then(function(response) {\n\n                            const type = dataUtilsService.type(restPath);\n                            const datalist = response[type];\n                            // the response should always be an array\n                            if (!angular.isArray(datalist)) {\n                                const e = `${datalist} is not an array`;\n                                $log.error(e);\n                                return;\n                            }\n\n                            // fill up the collection with initial data\n                            return collection.initial(datalist);\n                        })\n                    );\n\n                    return collection;\n                }\n\n\n                control(ep, id, method, params) {\n                    if (params == null) { params = {}; }\n                    const restPath = dataUtilsService.restPath([ep, id]);\n                    return restService.post(restPath, {\n                        id: this.getNextId(),\n                        jsonrpc: '2.0',\n                        method,\n                        params\n                    }\n                    );\n                }\n\n                // returns next id for jsonrpc2 control messages\n                getNextId() {\n                    if (this.jsonrpc == null) { this.jsonrpc = 1; }\n                    return this.jsonrpc++;\n                }\n\n                // generate functions for root endpoints\n                static generateEndpoints() {\n                    return ENDPOINTS.forEach(e => {\n                        // capitalize endpoint names\n                        const E = dataUtilsService.capitalize(e);\n                        return this.prototype[`get${E}`] = (...args) => self.get(e, ...Array.from(args));\n                    });\n                }\n\n                // opens a new accessor\n                open() {\n                    let DataAccessor;\n                    return new ((DataAccessor = (function() {\n                        let collectionRefs = undefined;\n                        DataAccessor = class DataAccessor {\n                            static initClass() {\n                                collectionRefs = [];\n                            }\n                            constructor() {\n                                this.constructor.generateEndpoints();\n                            }\n\n                            registerCollection(c) {\n                                return collectionRefs.push(c);\n                            }\n\n                            close() {\n                                return collectionRefs.forEach(c => c.close());\n                            }\n\n                            // Closes the group when the scope is destroyed\n                            closeOnDestroy(scope) {\n                                if (!angular.isFunction(scope.$on)) {\n                                    throw new TypeError(\"Parameter 'scope' doesn't have an $on function\");\n                                }\n                                scope.$on('$destroy', () => this.close());\n                                return this;\n                            }\n\n                            // Generate functions for root endpoints\n                            static generateEndpoints() {\n                                return ENDPOINTS.forEach(e => {\n                                    // capitalize endpoint names\n                                    const E = dataUtilsService.capitalize(e);\n                                    return this.prototype[`get${E}`] = function(...args) {\n                                        let query;\n                                        [args, query] = Array.from(dataUtilsService.splitOptions(args));\n                                        if (query.subscribe == null) { query.subscribe = true; }\n                                        query.accessor = this;\n                                        return self.get(e, ...Array.from(args), query);\n                                    };\n                                });\n                            }\n                        };\n                        DataAccessor.initClass();\n                        return DataAccessor;\n                    })()));\n                }\n                when(url, query, returnValue) {\n                    if ((returnValue == null)) {\n                        [query, returnValue] = Array.from([{}, query]);\n                    }\n                    if ((typeof jasmine !== 'undefined' && jasmine !== null) && !this.spied) {\n                        spyOn(this, 'get').and.callFake(this._mockGet);\n                        this.spied = true;\n                    }\n\n                    if (this.mocks[url] == null) { this.mocks[url] = {}; }\n                    return this.mocks[url][query] = returnValue;\n                }\n\n                expect(url, query, returnValue) {\n                    if ((returnValue == null)) {\n                        [query, returnValue] = Array.from([{}, query]);\n                    }\n                    if (this._expects == null) { this._expects = []; }\n                    this._expects.push([url, query]);\n                    return this.when(url, query, returnValue);\n                }\n\n                verifyNoOutstandingExpectation() {\n                    if ((this._expects != null) && this._expects.length) {\n                        return fail(`expecting ${this._expects.length} more data requests ` +\n                            `(${angular.toJson(this._expects)})`);\n                    }\n                }\n\n                // register return values with the .when function\n                // when testing get will return the given values\n                _mockGet(...args) {\n                    const [url, query] = Array.from(this.processArguments(args));\n                    const queryWithoutSubscribe = {};\n                    for (let k in query) {\n                        const v = query[k];\n                        if ((k !== \"subscribe\") && (k !== \"accessor\")) {\n                            queryWithoutSubscribe[k] = v;\n                        }\n                    }\n                    if (this._expects) {\n                        const [exp_url, exp_query] = Array.from(this._expects.shift());\n                        expect(exp_url).toEqual(url);\n                        expect(exp_query).toEqual(queryWithoutSubscribe);\n                    }\n                    const returnValue = (this.mocks[url] != null ? this.mocks[url][query] : undefined) || (this.mocks[url] != null ? this.mocks[url][queryWithoutSubscribe] : undefined);\n                    if ((returnValue == null)) { throw new Error(`No return value for: ${url} ` +\n                        `(${angular.toJson(queryWithoutSubscribe)})`); }\n                    const collection = this.createCollection(url, queryWithoutSubscribe, returnValue);\n                    return collection;\n                }\n\n                processArguments(args) {\n                    let query;\n                    [args, query] = Array.from(dataUtilsService.splitOptions(args));\n                    const restPath = dataUtilsService.restPath(args);\n                    return [restPath, query || {}];\n                }\n\n\n                // for easier testing\n                createCollection(url, query, response) {\n                    const restPath = url;\n                    const type = dataUtilsService.type(restPath);\n                    const collection = new Collection(restPath, query);\n\n                    // populate the response with default ids\n                    // for convenience\n                    const { id } = collection;\n                    let idCounter = 1;\n                    response.forEach(function(d) {\n                        if (!d.hasOwnProperty(id)) {\n                            return d[id] = idCounter++;\n                        }\n                    });\n\n                    collection.initial(response);\n                    return collection;\n                }\n            };\n            DataService.initClass();\n            return DataService;\n        })()));\n    }\n}\nData.initClass();\n\n\nangular.module('bbData')\n.service('dataService', ['$log', '$injector', '$q', 'restService', 'socketService',\n                         'dataUtilsService', 'Collection', 'ENDPOINTS', Data]);\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS201: Simplify complex destructure assignments\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass DataUtils {\n    constructor() {\n        let dataUtilsService;\n        return new (dataUtilsService = class dataUtilsService {\n            // capitalize first word\n            capitalize(string) {\n                return string[0].toUpperCase() + string.slice(1).toLowerCase();\n            }\n\n            // returns the type of the endpoint\n            type(arg) {\n                let a = this.copyOrSplit(arg);\n                a = a.filter(e => e !== '*');\n                // if the argument count is even, the last argument is an id\n                if ((a.length % 2) === 0) { a.pop(); }\n                let type = a.pop();\n                if (type === \"contents\") {\n                    type = \"logchunks\";\n                }\n                return type;\n            }\n            // singularize the type name\n            singularType(arg) {\n                return this.type(arg).replace(/s$/, '');\n            }\n\n            className(arg) {\n                return this.capitalize(this.singularType(arg));\n            }\n\n            classId(arg) {\n                if (this.singularType(arg) === \"forcescheduler\") {\n                    return \"name\";\n                }\n                if (this.singularType(arg) === \"buildset\") {\n                    return \"bsid\";\n                }\n                return this.singularType(arg) + \"id\";\n            }\n\n            socketPath(arg) {\n                const a = this.copyOrSplit(arg);\n                // if the argument count is even, the last argument is an id\n                // Format of properties endpoint is an exception\n                // and needs to be properties/*, not properties/*/*\n                const stars = ['*'];\n                // is it odd?\n                if (((a.length % 2) === 1) && !arg.endsWith(\"/properties\")) { stars.push('*'); }\n                return a.concat(stars).join('/');\n            }\n\n            socketPathRE(socketPath) {\n                return new RegExp(`^${socketPath.replace(/\\*/g, \"[^/]+\")}$`);\n            }\n\n            restPath(arg) {\n                let a = this.copyOrSplit(arg);\n                a = a.filter(e => e !== '*');\n                return a.join('/');\n            }\n\n            endpointPath(arg) {\n                // if the argument count is even, the last argument is an id\n                let a = this.copyOrSplit(arg);\n                a = a.filter(e => e !== '*');\n                // is it even?\n                if ((a.length % 2) === 0) { a.pop(); }\n                return a.join('/');\n            }\n\n            copyOrSplit(arrayOrString) {\n                if (angular.isArray(arrayOrString)) {\n                    // return a copy\n                    return arrayOrString.slice();\n                } else if (angular.isString(arrayOrString)) {\n                    // split the string to get an array\n                    return arrayOrString.split('/');\n                } else {\n                    throw new TypeError(`Parameter 'arrayOrString' must be a array or a string, not ${typeof arrayOrString}`);\n                }\n            }\n\n            unWrap(object, path) {\n                return object[this.type(path)];\n            }\n\n            splitOptions(args) {\n                // keep defined arguments only\n                let accessor;\n                args = args.filter(e => e != null);\n\n                let query = {}; // default\n                // get the query parameters\n                const last = args[args.length - 1];\n                const subscribe = (accessor = null);\n\n                if (angular.isObject(last)) {\n                    query = args.pop();\n                }\n\n                return [args, query];\n            }\n\n            parse(object) {\n                for (let k in object) {\n                    const v = object[k];\n                    try {\n                        object[k] = angular.fromJson(v);\n                    } catch (error) {}\n                } // ignore\n                return object;\n            }\n\n            numberOrString(str = null) {\n                // if already a number\n                if (angular.isNumber(str)) { return str; }\n                // else parse string to integer\n                const number = parseInt(str, 10);\n                if (!isNaN(number)) { return number; } else { return str; }\n            }\n\n            emailInString(string) {\n                if (!angular.isString(string)) {\n                    throw new TypeError(`Parameter 'string' must be a string, not ${typeof string}`);\n                }\n                const emailRegex = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*/;\n                try {\n                    return emailRegex.exec(string).pop() || '';\n                } catch (error) {\n                    return '';\n                }\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.service('dataUtilsService', [DataUtils]);","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Rest {\n    constructor($http, $q, API) {\n        let RestService;\n        return new (RestService = class RestService {\n            execute(config) {\n                return $q((resolve, reject) =>\n                    $http(config)\n                    .success(function(response) {\n                        try {\n                            const data = angular.fromJson(response);\n                            return resolve(data);\n                        } catch (e) {\n                            return reject(e);\n                        }}).error(reason => reject(reason))\n                );\n            }\n\n            get(url, params) {\n                if (params == null) { params = {}; }\n                const canceller = $q.defer();\n                const config = {\n                    method: 'GET',\n                    url: this.parse(API, url),\n                    params,\n                    headers: {\n                        'Accept': 'application/json'\n                    },\n                    timeout: canceller.promise\n                };\n\n                const promise = this.execute(config);\n                promise.cancel = canceller.resolve;\n                return promise;\n            }\n\n            post(url, data) {\n                if (data == null) { data = {}; }\n                const canceller = $q.defer();\n                const config = {\n                    method: 'POST',\n                    url: this.parse(API, url),\n                    data,\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    timeout: canceller.promise\n                };\n\n                const promise = this.execute(config);\n                promise.cancel = canceller.resolve;\n                return promise;\n            }\n\n            parse(...args) {\n                return args.join('/').replace(/\\/\\//, '/');\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.service('restService', ['$http', '$q', 'API', Rest]);","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Socket {\n    constructor($log, $q, $rootScope, $location, Stream, webSocketService) {\n        let SocketService;\n        return new ((SocketService = (function() {\n            SocketService = class SocketService {\n                static initClass() {\n                    // subscribe to event stream to get WebSocket messages\n                    this.prototype.eventStream = null;\n                }\n\n                constructor() {\n                    // waiting queue\n                    this.queue = [];\n                    // deferred object for resolving response promises\n                    // map of id: promise\n                    this.deferred = {};\n                    this.subscribers = {};\n                    // open socket\n                    this.open();\n                }\n\n                open() {\n                    if (this.socket == null) { this.socket = webSocketService.getWebSocket(this.getUrl()); }\n\n                    // flush queue on open\n                    this.socket.onopen = () => this.flush();\n\n                    return this.setupEventStream();\n                }\n\n                setupEventStream() {\n                    if (this.eventStream == null) { this.eventStream = new Stream(); }\n\n                    return this.socket.onmessage = message => {\n                        let id;\n                        try {\n                            const data = angular.fromJson(message.data);\n\n                            // response message\n                            if (data.code != null) {\n                                id = data._id;\n                                if (data.code === 200) { return (this.deferred[id] != null ? this.deferred[id].resolve(true) : undefined);\n                                } else { return (this.deferred[id] != null ? this.deferred[id].reject(data) : undefined); }\n                            // status update message\n                            } else {\n                                return $rootScope.$applyAsync(() => {\n                                    return this.eventStream.push(data);\n                                });\n                            }\n                        } catch (e) {\n                            return (this.deferred[id] != null ? this.deferred[id].reject(e) : undefined);\n                        }\n                    };\n                }\n\n                close() {\n                    return this.socket.close();\n                }\n\n                send(data) {\n                    // add _id to each message\n                    const id = this.nextId();\n                    data._id = id;\n                    if (this.deferred[id] == null) { this.deferred[id] = $q.defer(); }\n\n                    data = angular.toJson(data);\n                    // ReconnectingWebSocket does not put status constants on instance\n                    if (this.socket.readyState === (this.socket.OPEN || 1)) {\n                        this.socket.send(data);\n                    } else {\n                        // if the WebSocket is not open yet, add the data to the queue\n                        this.queue.push(data);\n                    }\n\n                    // return promise, which will be resolved once a response message has the same id\n                    return this.deferred[id].promise;\n                }\n\n                flush() {\n                    // send all the data waiting in the queue\n                    return (() => {\n                        let data;\n                        const result = [];\n                        while ((data = this.queue.pop())) {\n                            result.push(this.socket.send(data));\n                        }\n                        return result;\n                    })();\n                }\n\n                nextId() {\n                    if (this.id == null) { this.id = 0; }\n                    this.id = this.id < 1000 ? this.id + 1 : 0;\n                    return this.id;\n                }\n\n                getRootPath() {\n                    return location.pathname;\n                }\n\n                getUrl() {\n                    const host = $location.host();\n                    const protocol = $location.protocol() === 'https' ? 'wss' : 'ws';\n                    const defaultport = $location.protocol() === 'https' ? 443 : 80;\n                    const path = this.getRootPath();\n                    const port = $location.port() === defaultport ? '' : `:${$location.port()}`;\n                    return `${protocol}://${host}${port}${path}ws`;\n                }\n\n                // High level api. Maintain a list of subscribers for one event path\n                subscribe(eventPath, collection) {\n                    const l = this.subscribers[eventPath] != null ? this.subscribers[eventPath] : (this.subscribers[eventPath] = []);\n                    l.push(collection);\n                    if (l.length === 1) {\n                        return this.send({\n                            cmd: \"startConsuming\",\n                            path: eventPath\n                        });\n                    }\n                    return $q.resolve();\n                }\n\n                unsubscribe(eventPath, collection) {\n                    const l = this.subscribers[eventPath] != null ? this.subscribers[eventPath] : (this.subscribers[eventPath] = []);\n                    const pos = l.indexOf(collection);\n                    if (pos >= 0) {\n                        l.splice(pos, 1);\n                        if (l.length === 0) {\n                            return this.send({\n                                cmd: \"stopConsuming\",\n                                path: eventPath\n                            });\n                        }\n                    }\n                    return $q.resolve();\n                }\n            };\n            SocketService.initClass();\n            return SocketService;\n        })()));\n    }\n}\n\n\nangular.module('bbData')\n.service('socketService', ['$log', '$q', '$rootScope', '$location', 'Stream', 'webSocketService', Socket]);","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nvar WebSocketBackend = (function() {\n    let self = undefined;\n    let MockWebSocket = undefined;\n    WebSocketBackend = class WebSocketBackend {\n        static initClass() {\n            self = null;\n\n            this.prototype.sendQueue = [];\n            this.prototype.receiveQueue = [];\n\n            // mocked WebSocket\n            MockWebSocket = (function() {\n                MockWebSocket = class MockWebSocket {\n                    static initClass() {\n                        this.prototype.OPEN = 1;\n                    }\n                    send(message) {\n                        return self.receiveQueue.push(message);\n                    }\n                    close() { return (typeof this.onclose === 'function' ? this.onclose() : undefined); }\n                };\n                MockWebSocket.initClass();\n                return MockWebSocket;\n            })();\n        }\n        constructor() {\n            self = this;\n            this.webSocket = new MockWebSocket();\n        }\n        send(message) {\n            const data = {data: message};\n            return this.sendQueue.push(data);\n        }\n\n        flush() {\n            return (() => {\n                let message;\n                const result = [];\n                while ((message = this.sendQueue.shift())) {\n                    result.push(this.webSocket.onmessage(message));\n                }\n                return result;\n            })();\n        }\n\n        getWebSocket() {\n            return this.webSocket;\n        }\n    };\n    WebSocketBackend.initClass();\n    return WebSocketBackend;\n})();\n\n\nangular.module('bbData')\n.service('webSocketBackendService', [WebSocketBackend]);","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass WebSocket {\n    constructor($window) {\n        let WebSocketProvider;\n        return new (WebSocketProvider = class WebSocketProvider {\n            constructor() {}\n\n            // this function will be mocked in the tests\n            getWebSocket(url) {\n                const match = /wss?:\\/\\//.exec(url);\n\n                if (!match) {\n                    throw new Error('Invalid url provided');\n                }\n\n                // use ReconnectingWebSocket if available\n                // TODO write own implementation?\n                if ($window.ReconnectingWebSocket != null) {\n                    return new $window.ReconnectingWebSocket(url);\n                } else {\n                    return new $window.WebSocket(url);\n                }\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.service('webSocketService', ['$window', WebSocket]);","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Stream {\n    constructor() {\n        let StreamInstance;\n        return StreamInstance = (function() {\n            StreamInstance = class StreamInstance {\n                static initClass() {\n                    // the unsubscribe listener will be called on each unsubscribe call\n                    this.prototype.onUnsubscribe = null;\n                    this.prototype.listeners = [];\n                }\n\n                subscribe(listener) {\n                    if (!angular.isFunction(listener)) {\n                        throw new TypeError(`Parameter 'listener' must be a function, not ${typeof listener}`);\n                    }\n\n                    listener.id = this.generateId();\n                    this.listeners.push(listener);\n\n                    // unsubscribe\n                    return () => {\n                        const i = this.listeners.indexOf(listener);\n                        const removed = this.listeners.splice(i, 1);\n                        // call the unsubscribe listener if it's a function\n                        if (angular.isFunction(this.onUnsubscribe)) {\n                            return this.onUnsubscribe(listener);\n                        }\n                    };\n                }\n\n                push(data) {\n                    // call each listener\n                    return Array.from(this.listeners).map((listener) => listener(data));\n                }\n\n                destroy() {\n                    // @listeners = [], but keep the reference\n                    return (() => {\n                        const result = [];\n                        while (this.listeners.length > 0) {\n                            result.push(this.listeners.pop());\n                        }\n                        return result;\n                    })();\n                }\n\n                generateId() {\n                    if (this.lastId == null) { this.lastId = 0; }\n                    return this.lastId++;\n                }\n            };\n            StreamInstance.initClass();\n            return StreamInstance;\n        })();\n    }\n}\n\n\nangular.module('bbData')\n.factory('Stream', [Stream]);","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass Collection {\n    constructor($q, $injector, $log, dataUtilsService, socketService, DataQuery, $timeout) {\n        let CollectionInstance;\n\n        angular.isArray = (Array.isArray = arg => arg instanceof Array);\n        CollectionInstance = class CollectionInstance extends Array {\n            constructor(restPath, query, accessor) {\n                // this contructor is used to construct completely new instances only.\n                // We override constructor property for existing instances so that\n                // Array.prototype.filter() passes the restPath, query and accessor properties\n                // to the new instance.\n                super();\n                this.constructorImpl(restPath, query, accessor);\n            }\n\n            constructorImpl(restPath, query, accessor) {\n                let className;\n                this.listener = this.listener.bind(this);\n                this.restPath = restPath;\n                if (query == null) { query = {}; }\n                this.query = query;\n                this.accessor = accessor;\n                this.socketPath = dataUtilsService.socketPath(this.restPath);\n                this.type = dataUtilsService.type(this.restPath);\n                this.id = dataUtilsService.classId(this.restPath);\n                this.endpoint = dataUtilsService.endpointPath(this.restPath);\n                this.socketPathRE = dataUtilsService.socketPathRE(this.socketPath);\n                this.queryExecutor = new DataQuery(this.query);\n                // default event handlers\n                this.onUpdate = angular.noop;\n                this.onNew = angular.noop;\n                this.onChange = angular.noop;\n                this._new = [];\n                this._updated = [];\n                this._byId = {};\n                this.$resolved = false;\n                try {\n                    // try to get the wrapper class\n                    className = dataUtilsService.className(this.restPath);\n                    // the classes have the dataService as a dependency\n                    // $injector.get doesn't throw circular dependency exception\n                    this.WrapperClass = $injector.get(className);\n                } catch (e) {\n                    // use the Base class otherwise\n                    console.log(\"unknown wrapper for\", className);\n                    this.WrapperClass = $injector.get('Base');\n                }\n                socketService.eventStream.subscribe(this.listener);\n                if (this.accessor != null) {\n                    this.accessor.registerCollection(this);\n                }\n            }\n\n            then(callback) {\n                console.log(\"Should not use collection as a promise. Callback will be called several times!\");\n                return this.onChange = callback;\n            }\n\n            getArray() {\n                console.log(\"getArray() is deprecated. dataService.get() directly returns the collection!\");\n                return this;\n            }\n\n            get(id) {\n                return this._byId[id];\n            }\n\n            hasOwnProperty(id) {\n                return this._byId.hasOwnProperty(id);\n            }\n\n            listener(data) {\n                const key = data.k;\n                const message = data.m;\n                // Test if the message is for me\n                if (this.socketPathRE.test(key)) {\n                    this.put(message);\n                    this.recomputeQuery();\n                    return this.sendEvents();\n                }\n            }\n\n            subscribe() {\n                return socketService.subscribe(this.socketPath, this);\n            }\n\n            close() {\n                return socketService.unsubscribe(this.socketPath, this);\n            }\n\n            initial(data) {\n                this.$resolved = true;\n                // put items one by one if not already in the array\n                // if they are that means they come from an update event\n                // the event is always considered the latest data\n                // so we don't overwrite it with REST data\n                for (let i of Array.from(data)) {\n                    if (!this.hasOwnProperty(i[this.id])) {\n                        this.put(i);\n                    }\n                }\n                this.recomputeQuery();\n                return this.sendEvents({initial:true});\n            }\n\n            from(data) {\n                // put items one by one\n                for (let i of Array.from(data)) { this.put(i); }\n                this.recomputeQuery();\n                return this.sendEvents();\n            }\n\n            item(i) {\n                return this[i];\n            }\n\n            add(element) {\n                // don't create wrapper if element is filtered\n                if (this.queryExecutor.filter([element]).length === 0) {\n                    return;\n                }\n                const instance = new this.WrapperClass(element, this.endpoint);\n                instance.setAccessor(this.accessor);\n                instance.$collection = this;\n                this._new.push(instance);\n                this._byId[instance[this.id]] = instance;\n                return this.push(instance);\n            }\n\n            put(element) {\n                for (let old of Array.from(this)) {\n                    if (old[this.id] === element[this.id]) {\n                        old.update(element);\n                        this._updated.push(old);\n                        return;\n                    }\n                }\n                // if not found, add it.\n                return this.add(element);\n            }\n\n            clear() {\n                return (() => {\n                    const result = [];\n                    while (this.length > 0) {\n                        result.push(this.pop());\n                    }\n                    return result;\n                })();\n            }\n\n            delete(element) {\n                const index = this.indexOf(element);\n                if (index > -1) { return this.splice(index, 1); }\n            }\n\n            recomputeQuery() {\n                return this.queryExecutor.computeQuery(this);\n            }\n\n            sendEvents(opts){\n                // send the events asynchronously\n                const { _new } = this;\n                const { _updated } = this;\n                this._updated = [];\n                this._new = [];\n                return $timeout(() => {\n                    let i;\n                    let changed = false;\n                    for (i of Array.from(_new)) {\n                        // is it still in the array?\n                        if (Array.from(this).includes(i)) {\n                            this.onNew(i);\n                            changed = true;\n                        }\n                    }\n\n                    for (i of Array.from(_updated)) {\n                        // is it still in the array?\n                        if (Array.from(this).includes(i)) {\n                            this.onUpdate(i);\n                            changed = true;\n                        }\n                    }\n\n                    if (changed || (opts != null ? opts.initial : undefined)) {\n                        return this.onChange(this);\n                    }\n                }\n                , 0);\n            }\n        };\n        // see explanation in CollectionInstance.constructor() above\n        Object.defineProperty(CollectionInstance.prototype, 'constructor', {\n            get: function() {\n                let copyFrom = this;\n                return function(length) {\n                    return copyFrom.constructorImpl(copyFrom.restPath, copyFrom.query,\n                                                    copyfrom.accessor);\n                };\n            }\n        });\n        return CollectionInstance;\n    }\n}\n\n\nangular.module('bbData')\n.factory('Collection', ['$q', '$injector', '$log', 'dataUtilsService', 'socketService', 'DataQuery', '$timeout', Collection]);","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS203: Remove `|| {}` from converted for-own loops\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nclass DataQuery {\n    constructor($http, $q, API) {\n        let DataQueryClass;\n        return (DataQueryClass = class DataQueryClass {\n            constructor(query) {\n                if (query == null) { query = {}; }\n                this.query = query;\n                this.filters = {};\n                for (let fieldAndOperator in query) {\n                    let value = query[fieldAndOperator];\n                    if (['field', 'limit', 'offset', 'order', 'property'].indexOf(fieldAndOperator) < 0) {\n                        if (['on', 'true', 'yes'].indexOf(value) > -1) { value = true;\n                        } else if (['off', 'false', 'no'].indexOf(value) > -1) { value = false; }\n                        this.filters[fieldAndOperator] = value;\n                    }\n                }\n            }\n\n            computeQuery(array) {\n                // 1. filtering\n                this.filter(array);\n\n                // 2. sorting\n                const order = this.query != null ? this.query.order : undefined;\n                this.sort(array, order);\n\n                // 3. limit\n                const limit = this.query != null ? this.query.limit : undefined;\n                return this.limit(array, limit);\n            }\n\n\n            isFiltered(v) {\n                const cmpByOp = {};\n                for (let fieldAndOperator in this.filters) {\n                    const value = this.filters[fieldAndOperator];\n                    const [field, operator] = Array.from(fieldAndOperator.split('__'));\n                    let cmp = false;\n                    switch (operator) {\n                        case 'ne': cmp = v[field] !== value; break;\n                        case 'lt': cmp = v[field] <  value; break;\n                        case 'le': cmp = v[field] <= value; break;\n                        case 'gt': cmp = v[field] >  value; break;\n                        case 'ge': cmp = v[field] >= value; break;\n                        default: cmp = (v[field] === value) ||\n                            (angular.isArray(v[field]) && Array.from(v[field]).includes(value)) ||\n                            (angular.isArray(value) && (value.length === 0)) ||\n                            (angular.isArray(value) && Array.from(value).includes(v[field])) ||\n                            // private fields added by the data service\n                            (v[`_${field}`] === value) ||\n                            (angular.isArray(v[`_${field}`]) && Array.from(v[`_${field}`]).includes(value)) ||\n                            (angular.isArray(value) && Array.from(value).includes(v[`_${field}`]));\n                    }\n                    cmpByOp[fieldAndOperator] = cmpByOp[fieldAndOperator] || cmp;\n                }\n                for (let op of Object.keys(cmpByOp || {})) {\n                    v = cmpByOp[op];\n                    if (!v) { return false; }\n                }\n                return true;\n            }\n\n            filter(array) {\n                let i = 0;\n                return (() => {\n                    const result = [];\n                    while (i < array.length) {\n                        const v = array[i];\n                        if (this.isFiltered(v)) {\n                            result.push(i += 1);\n                        } else {\n                            result.push(array.splice(i, 1));\n                        }\n                    }\n                    return result;\n                })();\n            }\n\n            sort(array, order) {\n                const compare = function(property) {\n                    let reverse = false;\n                    if (property[0] === '-') {\n                        property = property.slice(1);\n                        reverse = true;\n                    }\n\n                    return function(a, b) {\n                        if (reverse) { [a, b] = Array.from([b, a]); }\n\n                        if (a[property] < b[property]) { return -1;\n                        } else if (a[property] > b[property]) { return 1;\n                        } else { return 0; }\n                    };\n                };\n                if (angular.isString(order)) {\n                    return array.sort(compare(order));\n                } else if (angular.isArray(order)) {\n                    return array.sort(function(a, b) {\n                        for (let o of Array.from(order)) {\n                            const f = compare(o)(a, b);\n                            if (f) { return f; }\n                        }\n                        return 0;\n                    });\n                }\n            }\n\n            limit(array, limit) {\n                return (() => {\n                    const result = [];\n                    while (array.length > limit) {\n                        result.push(array.pop());\n                    }\n                    return result;\n                })();\n            }\n        });\n    }\n}\n\n\nangular.module('bbData')\n.factory('DataQuery', ['$http', '$q', 'API', DataQuery]);"],"sourceRoot":"/source/"}